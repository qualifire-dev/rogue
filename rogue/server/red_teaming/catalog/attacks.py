"""
Attack Catalog for Red Teaming.

Contains all attack technique definitions organized by category.

Attack Types:
- FREE attacks: Implemented locally in rogue/server/red_teaming/attacks/
- PREMIUM attacks: Require Deckard service (QUALIFIRE_API_KEY)

Premium attacks are NOT implemented locally - they are generated by the
Deckard premium attack service via the API.
"""

from enum import Enum
from typing import Dict, List, Optional

from ..models import AttackCategory, AttackDef


class AttackId(str, Enum):
    """Enum of all attack IDs for type safety."""

    # Free single-turn attacks
    BASE64 = "base64"
    ROT13 = "rot13"
    PROMPT_INJECTION = "prompt-injection"
    ROLEPLAY = "roleplay"
    PROMPT_PROBING = "prompt-probing"

    # Premium single-turn attacks
    HEX = "hex"
    LEETSPEAK = "leetspeak"
    HOMOGLYPH = "homoglyph"
    MATH_PROBLEM = "math-problem"
    GRAY_BOX = "gray-box"
    MULTILINGUAL = "multilingual"
    CONTEXT_POISONING = "context-poisoning"
    GOAL_REDIRECTION = "goal-redirection"
    INPUT_BYPASS = "input-bypass"
    PERMISSION_ESCALATION = "permission-escalation"
    SYSTEM_OVERRIDE = "system-override"
    SEMANTIC_MANIPULATION = "semantic-manipulation"
    CITATION = "citation"
    GCG = "gcg"
    LIKERT_JAILBREAK = "likert-jailbreak"
    BEST_OF_N = "best-of-n"

    # Premium multi-turn attacks
    SOCIAL_ENGINEERING_PROMPT_EXTRACTION = "social-engineering-prompt-extraction"
    MULTI_TURN_JAILBREAK = "multi-turn-jailbreak"
    GOAT = "goat"
    MISCHIEVOUS_USER = "mischievous-user"
    SIMBA = "simba"
    CRESCENDO = "crescendo"
    LINEAR_JAILBREAK = "linear-jailbreak"
    SEQUENTIAL_JAILBREAK = "sequential-jailbreak"
    BAD_LIKERT_JUDGE = "bad-likert-judge"

    # Agentic attacks
    ITERATIVE_JAILBREAK = "iterative-jailbreak"
    META_AGENT_JAILBREAK = "meta-agent-jailbreak"
    HYDRA = "hydra"
    TREE_JAILBREAK = "tree-jailbreak"
    SINGLE_TURN_COMPOSITE = "single-turn-composite"


# =============================================================================
# FREE SINGLE-TURN ATTACKS (Implemented locally - used in basic scans)
# =============================================================================

FREE_SINGLE_TURN_ATTACKS = [
    AttackDef(
        id=AttackId.BASE64,
        name="Base64 Encoding",
        category=AttackCategory.SINGLE_TURN,
        description="Encodes the attack input in Base64 to bypass text-based filters",
    ),
    AttackDef(
        id=AttackId.ROT13,
        name="ROT13 Encoding",
        category=AttackCategory.SINGLE_TURN,
        description="Encodes the attack input using ROT13 cipher to bypass filters",
    ),
    AttackDef(
        id=AttackId.PROMPT_INJECTION,
        name="Prompt Injection",
        category=AttackCategory.SINGLE_TURN,
        description="Direct prompt injection to override system instructions",
    ),
    AttackDef(
        id=AttackId.ROLEPLAY,
        name="Roleplay",
        category=AttackCategory.SINGLE_TURN,
        description="Uses roleplay scenarios to bypass safety filters",
    ),
    AttackDef(
        id=AttackId.PROMPT_PROBING,
        name="Prompt Probing",
        category=AttackCategory.SINGLE_TURN,
        description="Attempts to extract system prompts through probing questions",
    ),
]

# =============================================================================
# PREMIUM SINGLE-TURN ATTACKS (Require Deckard service)
# =============================================================================

PREMIUM_SINGLE_TURN_ATTACKS = [
    # Encoding-based attacks (premium)
    AttackDef(
        id=AttackId.HEX,
        name="Hex Encoding",
        category=AttackCategory.SINGLE_TURN,
        description="Encodes the attack input in hexadecimal to bypass filters",
        premium=True,
    ),
    AttackDef(
        id=AttackId.LEETSPEAK,
        name="Leetspeak",
        category=AttackCategory.SINGLE_TURN,
        description="Transforms text using leetspeak (1337) character substitutions",
        premium=True,
    ),
    AttackDef(
        id=AttackId.HOMOGLYPH,
        name="Homoglyph Encoding",
        category=AttackCategory.SINGLE_TURN,
        description="Uses visually similar Unicode characters to bypass text filters",
        premium=True,
    ),
    # Context/manipulation attacks (premium)
    AttackDef(
        id=AttackId.MATH_PROBLEM,
        name="Math Prompt",
        category=AttackCategory.SINGLE_TURN,
        description="Encodes harmful requests in math to distract filters",
        premium=True,
    ),
    AttackDef(
        id=AttackId.GRAY_BOX,
        name="Gray Box",
        category=AttackCategory.SINGLE_TURN,
        description="Injects fake internal info to gain trust or trick model",
        premium=True,
    ),
    AttackDef(
        id=AttackId.MULTILINGUAL,
        name="Multilingual",
        category=AttackCategory.SINGLE_TURN,
        description="Uses translation framing to bypass language-specific filters",
        premium=True,
    ),
    AttackDef(
        id=AttackId.CONTEXT_POISONING,
        name="Context Poisoning",
        category=AttackCategory.SINGLE_TURN,
        description="Injects malicious context or instructions to alter model behavior",
        premium=True,
    ),
    AttackDef(
        id=AttackId.GOAL_REDIRECTION,
        name="Goal Redirection",
        category=AttackCategory.SINGLE_TURN,
        description="Attempts to shift the goal of the conversation mid-prompt",
        premium=True,
    ),
    AttackDef(
        id=AttackId.INPUT_BYPASS,
        name="Input Bypass",
        category=AttackCategory.SINGLE_TURN,
        description="Splits payload or uses delimiters to bypass regex filters",
        premium=True,
    ),
    AttackDef(
        id=AttackId.PERMISSION_ESCALATION,
        name="Permission Escalation",
        category=AttackCategory.SINGLE_TURN,
        description="Attempts to bypass permission checks by claiming elevated status",
        premium=True,
    ),
    AttackDef(
        id=AttackId.SYSTEM_OVERRIDE,
        name="System Override",
        category=AttackCategory.SINGLE_TURN,
        description="Uses explicit system override commands to bypass restrictions",
        premium=True,
    ),
    AttackDef(
        id=AttackId.SEMANTIC_MANIPULATION,
        name="Semantic Manipulation",
        category=AttackCategory.SINGLE_TURN,
        description="Uses semantic tricks and complex phrasing to disguise intent",
        premium=True,
    ),
    # Advanced premium attacks
    AttackDef(
        id=AttackId.CITATION,
        name="Citation",
        category=AttackCategory.SINGLE_TURN,
        description="Frames harmful content as academic citations or references",
        premium=True,
    ),
    AttackDef(
        id=AttackId.GCG,
        name="GCG (Greedy Coordinate Gradient)",
        category=AttackCategory.SINGLE_TURN,
        description="Gradient-based adversarial suffix generation",
        premium=True,
    ),
    AttackDef(
        id=AttackId.LIKERT_JAILBREAK,
        name="Likert-based Jailbreaks",
        category=AttackCategory.SINGLE_TURN,
        description="Uses Likert scale framing to manipulate responses",
        premium=True,
    ),
    AttackDef(
        id=AttackId.BEST_OF_N,
        name="Best-of-N",
        category=AttackCategory.SINGLE_TURN,
        description="Generates multiple variations and selects the most effective",
        premium=True,
    ),
]

# Combined single-turn attacks
SINGLE_TURN_ATTACKS = FREE_SINGLE_TURN_ATTACKS + PREMIUM_SINGLE_TURN_ATTACKS

# =============================================================================
# FREE MULTI-TURN ATTACKS (None currently - all multi-turn are premium)
# =============================================================================

FREE_MULTI_TURN_ATTACKS: List[AttackDef] = [
    # No free multi-turn attacks currently
]

# =============================================================================
# PREMIUM MULTI-TURN ATTACKS (Require Deckard service)
# =============================================================================

PREMIUM_MULTI_TURN_ATTACKS = [
    AttackDef(
        id=AttackId.SOCIAL_ENGINEERING_PROMPT_EXTRACTION,
        name="Social Engineering Prompt Extraction",
        category=AttackCategory.MULTI_TURN,
        description=(
            "Uses trust-building and social engineering to extract "
            "system prompts through multi-turn conversation"
        ),
        premium=True,
    ),
    AttackDef(
        id=AttackId.MULTI_TURN_JAILBREAK,
        name="Multi-turn Jailbreaks",
        category=AttackCategory.MULTI_TURN,
        description="Progressive jailbreaking across multiple conversation turns",
        premium=True,
    ),
    AttackDef(
        id=AttackId.GOAT,
        name="GOAT",
        category=AttackCategory.MULTI_TURN,
        description="Generative Offensive Agent Tester - adaptive multi-turn attacks",
        premium=True,
    ),
    AttackDef(
        id=AttackId.MISCHIEVOUS_USER,
        name="Mischievous User",
        category=AttackCategory.MULTI_TURN,
        description="Simulates a persistent mischievous user trying various tactics",
        premium=True,
    ),
    AttackDef(
        id=AttackId.SIMBA,
        name="Simba",
        category=AttackCategory.MULTI_TURN,
        description="Simulation-based multi-turn adversarial attacks",
        premium=True,
    ),
    AttackDef(
        id=AttackId.CRESCENDO,
        name="Crescendo",
        category=AttackCategory.MULTI_TURN,
        description="Gradually escalating attack intensity across turns",
        premium=True,
    ),
    AttackDef(
        id=AttackId.LINEAR_JAILBREAK,
        name="Linear Jailbreaking",
        category=AttackCategory.MULTI_TURN,
        description="Sequential jailbreaking strategy with linear progression",
        premium=True,
    ),
    AttackDef(
        id=AttackId.SEQUENTIAL_JAILBREAK,
        name="Sequential Jailbreak",
        category=AttackCategory.MULTI_TURN,
        description="Combines multiple single-turn techniques in sequence",
        premium=True,
    ),
    AttackDef(
        id=AttackId.BAD_LIKERT_JUDGE,
        name="Bad Likert Judge",
        category=AttackCategory.MULTI_TURN,
        description="Manipulates the agent by acting as a strict evaluator",
        premium=True,
    ),
]

# Combined multi-turn attacks
MULTI_TURN_ATTACKS = FREE_MULTI_TURN_ATTACKS + PREMIUM_MULTI_TURN_ATTACKS

# =============================================================================
# AGENTIC ATTACKS (All Premium - Require Deckard service)
# =============================================================================

AGENTIC_ATTACKS = [
    AttackDef(
        id=AttackId.ITERATIVE_JAILBREAK,
        name="Iterative Jailbreaks",
        category=AttackCategory.AGENTIC,
        description="AI-driven iterative refinement of jailbreak attempts",
        premium=True,
    ),
    AttackDef(
        id=AttackId.META_AGENT_JAILBREAK,
        name="Meta-Agent Jailbreaks",
        category=AttackCategory.AGENTIC,
        description="Uses a meta-agent to orchestrate attack strategies",
        premium=True,
    ),
    AttackDef(
        id=AttackId.HYDRA,
        name="Hydra Multi-turn",
        category=AttackCategory.AGENTIC,
        description="Multi-headed attack strategy with parallel exploration",
        premium=True,
    ),
    AttackDef(
        id=AttackId.TREE_JAILBREAK,
        name="Tree-based Jailbreaks",
        category=AttackCategory.AGENTIC,
        description="Tree search-based exploration of attack vectors",
        premium=True,
    ),
    AttackDef(
        id=AttackId.SINGLE_TURN_COMPOSITE,
        name="Single Turn Composite",
        category=AttackCategory.AGENTIC,
        description="Combines multiple single-turn attacks in one message",
        premium=True,
    ),
]


# =============================================================================
# COMBINED CATALOG
# =============================================================================


def _build_catalog() -> Dict[str, AttackDef]:
    """Build the complete attack catalog."""
    all_attacks = SINGLE_TURN_ATTACKS + MULTI_TURN_ATTACKS + AGENTIC_ATTACKS
    return {a.id: a for a in all_attacks}


# The complete attack catalog indexed by ID
ATTACK_CATALOG: Dict[str, AttackDef] = _build_catalog()


def get_attack(attack_id: str) -> Optional[AttackDef]:
    """Get an attack definition by ID."""
    return ATTACK_CATALOG.get(attack_id)


def get_attacks_by_category(category: AttackCategory) -> List[AttackDef]:
    """Get all attacks in a category."""
    return [a for a in ATTACK_CATALOG.values() if a.category == category]


def get_all_attacks() -> List[AttackDef]:
    """Get all attack definitions."""
    return list(ATTACK_CATALOG.values())


def get_free_attacks() -> List[AttackDef]:
    """Get all non-premium attacks (implemented locally)."""
    return [a for a in ATTACK_CATALOG.values() if not a.premium]


def get_premium_attacks() -> List[AttackDef]:
    """Get all premium attacks (require Deckard service)."""
    return [a for a in ATTACK_CATALOG.values() if a.premium]


def get_locally_implemented_attacks() -> List[str]:
    """
    Get attack IDs that are implemented locally (not requiring Deckard).

    These attacks have local implementations in rogue/server/red_teaming/attacks/
    """
    return [a.id for a in FREE_SINGLE_TURN_ATTACKS + FREE_MULTI_TURN_ATTACKS]


def get_deckard_required_attacks() -> List[str]:
    """
    Get attack IDs that require the Deckard premium service.

    These attacks are NOT implemented locally - they are generated via
    the Deckard API with a QUALIFIRE_API_KEY.
    """
    return [a.id for a in ATTACK_CATALOG.values() if a.premium]


def get_basic_scan_attacks() -> List[str]:
    """
    Get attack IDs for basic (free) scan.

    Returns a curated list of effective free single-turn attacks.
    """
    return [
        AttackId.BASE64.value,
        AttackId.ROT13.value,
        AttackId.PROMPT_INJECTION.value,
        AttackId.ROLEPLAY.value,
        AttackId.PROMPT_PROBING.value,
    ]


def get_full_scan_attacks() -> List[str]:
    """
    Get all attack IDs for full scan.

    Returns all attack IDs including premium ones.
    Note: Premium attacks require QUALIFIRE_API_KEY to use.
    """
    return list(ATTACK_CATALOG.keys())


def get_attacks_for_vulnerability(vulnerability_id: str) -> List[str]:
    """
    Get recommended attack IDs for a specific vulnerability.

    This is a convenience function that looks up the vulnerability's
    default_attacks. If you need the mapping, import from vulnerabilities.py.
    """
    from .vulnerabilities import get_vulnerability

    vuln = get_vulnerability(vulnerability_id)
    if vuln:
        return vuln.default_attacks
    return []


def is_premium_attack(attack_id: str) -> bool:
    """Check if an attack requires the Deckard premium service."""
    attack = ATTACK_CATALOG.get(attack_id)
    return attack.premium if attack else False
