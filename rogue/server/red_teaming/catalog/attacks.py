"""
Attack Catalog for Red Teaming.

Contains all attack technique definitions organized by category.

Attack Types:
- FREE attacks: Implemented locally in rogue/server/red_teaming/attacks/
- PREMIUM attacks: Require Deckard service (QUALIFIRE_API_KEY)

Premium attacks are NOT implemented locally - they are generated by the
Deckard premium attack service via the API.
"""

from typing import Dict, List, Optional

from ..models import AttackCategory, AttackDef

# =============================================================================
# FREE SINGLE-TURN ATTACKS (Implemented locally)
# =============================================================================

FREE_SINGLE_TURN_ATTACKS = [
    AttackDef(
        id="base64",
        name="Base64 Encoding",
        category=AttackCategory.SINGLE_TURN,
        description="Encodes the attack input in Base64 to bypass text-based filters",
    ),
    AttackDef(
        id="rot13",
        name="ROT13 Encoding",
        category=AttackCategory.SINGLE_TURN,
        description="Encodes the attack input using ROT13 cipher to bypass filters",
    ),
    AttackDef(
        id="hex",
        name="Hex Encoding",
        category=AttackCategory.SINGLE_TURN,
        description="Encodes the attack input in hexadecimal to bypass filters",
    ),
    AttackDef(
        id="leetspeak",
        name="Leetspeak",
        category=AttackCategory.SINGLE_TURN,
        description="Transforms text using leetspeak (1337) character substitutions",
    ),
    AttackDef(
        id="prompt-injection",
        name="Prompt Injection",
        category=AttackCategory.SINGLE_TURN,
        description="Direct prompt injection to override system instructions",
    ),
    AttackDef(
        id="math-problem",
        name="Math Prompt",
        category=AttackCategory.SINGLE_TURN,
        description="Encodes harmful requests in math to distract filters",
    ),
    AttackDef(
        id="roleplay",
        name="Roleplay",
        category=AttackCategory.SINGLE_TURN,
        description="Uses roleplay scenarios to bypass safety filters",
    ),
    AttackDef(
        id="prompt-probing",
        name="Prompt Probing",
        category=AttackCategory.SINGLE_TURN,
        description="Attempts to extract system prompts through probing questions",
    ),
    AttackDef(
        id="gray-box",
        name="Gray Box",
        category=AttackCategory.SINGLE_TURN,
        description="Injects fake internal info to gain trust or trick model",
    ),
    AttackDef(
        id="multilingual",
        name="Multilingual",
        category=AttackCategory.SINGLE_TURN,
        description="Uses translation framing to bypass language-specific filters",
    ),
    AttackDef(
        id="context-poisoning",
        name="Context Poisoning",
        category=AttackCategory.SINGLE_TURN,
        description="Injects malicious context or instructions to alter model behavior",
    ),
    AttackDef(
        id="goal-redirection",
        name="Goal Redirection",
        category=AttackCategory.SINGLE_TURN,
        description="Attempts to shift the goal of the conversation mid-prompt",
    ),
    AttackDef(
        id="input-bypass",
        name="Input Bypass",
        category=AttackCategory.SINGLE_TURN,
        description="Splits payload or uses delimiters to bypass regex filters",
    ),
    AttackDef(
        id="permission-escalation",
        name="Permission Escalation",
        category=AttackCategory.SINGLE_TURN,
        description="Attempts to bypass permission checks by claiming elevated status",
    ),
    AttackDef(
        id="system-override",
        name="System Override",
        category=AttackCategory.SINGLE_TURN,
        description="Uses explicit system override commands to bypass restrictions",
    ),
    AttackDef(
        id="semantic-manipulation",
        name="Semantic Manipulation",
        category=AttackCategory.SINGLE_TURN,
        description="Uses semantic tricks and complex phrasing to disguise intent",
    ),
]

# =============================================================================
# PREMIUM SINGLE-TURN ATTACKS (Require Deckard service)
# =============================================================================

PREMIUM_SINGLE_TURN_ATTACKS = [
    AttackDef(
        id="homoglyph",
        name="Homoglyph Encoding",
        category=AttackCategory.SINGLE_TURN,
        description="Uses visually similar Unicode characters to bypass text filters",
        premium=True,
    ),
    AttackDef(
        id="citation",
        name="Citation",
        category=AttackCategory.SINGLE_TURN,
        description="Frames harmful content as academic citations or references",
        premium=True,
    ),
    AttackDef(
        id="gcg",
        name="GCG (Greedy Coordinate Gradient)",
        category=AttackCategory.SINGLE_TURN,
        description="Gradient-based adversarial suffix generation",
        premium=True,
    ),
    AttackDef(
        id="likert-jailbreak",
        name="Likert-based Jailbreaks",
        category=AttackCategory.SINGLE_TURN,
        description="Uses Likert scale framing to manipulate responses",
        premium=True,
    ),
    AttackDef(
        id="best-of-n",
        name="Best-of-N",
        category=AttackCategory.SINGLE_TURN,
        description="Generates multiple variations and selects the most effective",
        premium=True,
    ),
]

# Combined single-turn attacks
SINGLE_TURN_ATTACKS = FREE_SINGLE_TURN_ATTACKS + PREMIUM_SINGLE_TURN_ATTACKS

# =============================================================================
# FREE MULTI-TURN ATTACKS (Implemented locally)
# =============================================================================

FREE_MULTI_TURN_ATTACKS = [
    AttackDef(
        id="social-engineering-prompt-extraction",
        name="Social Engineering Prompt Extraction",
        category=AttackCategory.MULTI_TURN,
        description=(
            "Uses trust-building and social engineering to extract "
            "system prompts through multi-turn conversation"
        ),
        premium=False,
    ),
]

# =============================================================================
# PREMIUM MULTI-TURN ATTACKS (Require Deckard service)
# =============================================================================

PREMIUM_MULTI_TURN_ATTACKS = [
    AttackDef(
        id="multi-turn-jailbreak",
        name="Multi-turn Jailbreaks",
        category=AttackCategory.MULTI_TURN,
        description="Progressive jailbreaking across multiple conversation turns",
        premium=True,
    ),
    AttackDef(
        id="goat",
        name="GOAT",
        category=AttackCategory.MULTI_TURN,
        description="Generative Offensive Agent Tester - adaptive multi-turn attacks",
        premium=True,
    ),
    AttackDef(
        id="mischievous-user",
        name="Mischievous User",
        category=AttackCategory.MULTI_TURN,
        description="Simulates a persistent mischievous user trying various tactics",
        premium=True,
    ),
    AttackDef(
        id="simba",
        name="Simba",
        category=AttackCategory.MULTI_TURN,
        description="Simulation-based multi-turn adversarial attacks",
        premium=True,
    ),
    AttackDef(
        id="crescendo",
        name="Crescendo",
        category=AttackCategory.MULTI_TURN,
        description="Gradually escalating attack intensity across turns",
        premium=True,
    ),
    AttackDef(
        id="linear-jailbreak",
        name="Linear Jailbreaking",
        category=AttackCategory.MULTI_TURN,
        description="Sequential jailbreaking strategy with linear progression",
        premium=True,
    ),
    AttackDef(
        id="sequential-jailbreak",
        name="Sequential Jailbreak",
        category=AttackCategory.MULTI_TURN,
        description="Combines multiple single-turn techniques in sequence",
        premium=True,
    ),
    AttackDef(
        id="bad-likert-judge",
        name="Bad Likert Judge",
        category=AttackCategory.MULTI_TURN,
        description="Manipulates the agent by acting as a strict evaluator",
        premium=True,
    ),
]

# Combined multi-turn attacks
MULTI_TURN_ATTACKS = FREE_MULTI_TURN_ATTACKS + PREMIUM_MULTI_TURN_ATTACKS

# =============================================================================
# AGENTIC ATTACKS (All Premium - Require Deckard service)
# =============================================================================

AGENTIC_ATTACKS = [
    AttackDef(
        id="iterative-jailbreak",
        name="Iterative Jailbreaks",
        category=AttackCategory.AGENTIC,
        description="AI-driven iterative refinement of jailbreak attempts",
        premium=True,
    ),
    AttackDef(
        id="meta-agent-jailbreak",
        name="Meta-Agent Jailbreaks",
        category=AttackCategory.AGENTIC,
        description="Uses a meta-agent to orchestrate attack strategies",
        premium=True,
    ),
    AttackDef(
        id="hydra",
        name="Hydra Multi-turn",
        category=AttackCategory.AGENTIC,
        description="Multi-headed attack strategy with parallel exploration",
        premium=True,
    ),
    AttackDef(
        id="tree-jailbreak",
        name="Tree-based Jailbreaks",
        category=AttackCategory.AGENTIC,
        description="Tree search-based exploration of attack vectors",
        premium=True,
    ),
    AttackDef(
        id="single-turn-composite",
        name="Single Turn Composite",
        category=AttackCategory.AGENTIC,
        description="Combines multiple single-turn attacks in one message",
        premium=True,
    ),
]


# =============================================================================
# COMBINED CATALOG
# =============================================================================


def _build_catalog() -> Dict[str, AttackDef]:
    """Build the complete attack catalog."""
    all_attacks = SINGLE_TURN_ATTACKS + MULTI_TURN_ATTACKS + AGENTIC_ATTACKS
    return {a.id: a for a in all_attacks}


# The complete attack catalog indexed by ID
ATTACK_CATALOG: Dict[str, AttackDef] = _build_catalog()


def get_attack(attack_id: str) -> Optional[AttackDef]:
    """Get an attack definition by ID."""
    return ATTACK_CATALOG.get(attack_id)


def get_attacks_by_category(category: AttackCategory) -> List[AttackDef]:
    """Get all attacks in a category."""
    return [a for a in ATTACK_CATALOG.values() if a.category == category]


def get_all_attacks() -> List[AttackDef]:
    """Get all attack definitions."""
    return list(ATTACK_CATALOG.values())


def get_free_attacks() -> List[AttackDef]:
    """Get all non-premium attacks (implemented locally)."""
    return [a for a in ATTACK_CATALOG.values() if not a.premium]


def get_premium_attacks() -> List[AttackDef]:
    """Get all premium attacks (require Deckard service)."""
    return [a for a in ATTACK_CATALOG.values() if a.premium]


def get_locally_implemented_attacks() -> List[str]:
    """
    Get attack IDs that are implemented locally (not requiring Deckard).

    These attacks have local implementations in rogue/server/red_teaming/attacks/
    """
    return [a.id for a in FREE_SINGLE_TURN_ATTACKS + FREE_MULTI_TURN_ATTACKS]


def get_deckard_required_attacks() -> List[str]:
    """
    Get attack IDs that require the Deckard premium service.

    These attacks are NOT implemented locally - they are generated via
    the Deckard API with a QUALIFIRE_API_KEY.
    """
    return [a.id for a in ATTACK_CATALOG.values() if a.premium]


def get_basic_scan_attacks() -> List[str]:
    """
    Get attack IDs for basic (free) scan.

    Returns a curated list of effective free attacks.
    """
    return [
        "base64",
        "rot13",
        "prompt-injection",
        "roleplay",
        "prompt-probing",
        "social-engineering-prompt-extraction",
    ]


def get_full_scan_attacks() -> List[str]:
    """
    Get all attack IDs for full scan.

    Returns all attack IDs including premium ones.
    Note: Premium attacks require QUALIFIRE_API_KEY to use.
    """
    return list(ATTACK_CATALOG.keys())


def get_attacks_for_vulnerability(vulnerability_id: str) -> List[str]:
    """
    Get recommended attack IDs for a specific vulnerability.

    This is a convenience function that looks up the vulnerability's
    default_attacks. If you need the mapping, import from vulnerabilities.py.
    """
    from .vulnerabilities import get_vulnerability

    vuln = get_vulnerability(vulnerability_id)
    if vuln:
        return vuln.default_attacks
    return []


def is_premium_attack(attack_id: str) -> bool:
    """Check if an attack requires the Deckard premium service."""
    attack = ATTACK_CATALOG.get(attack_id)
    return attack.premium if attack else False
